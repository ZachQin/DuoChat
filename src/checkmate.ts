import { TypeChatLanguageModel } from "./model";

export interface Checkmate {
    executor: TypeChatLanguageModel;
    verifier: TypeChatLanguageModel;
    refinementRounds: number;
    maxAttempts: number;
    debug: boolean;

    createExecuteInitialPrompt(taskDescription: string): string;
    createExecuteFollowupPrompt(): string;
    createVerifyInitialPrompt(taskDescription: string, executorSolution: string): string;
    createVerifyFollowupPrompt(): string;
    perform(taskDescription: string): Promise<string>;
}

interface RoundRecord {
    executorPrompt: string;
    executorSolution: string;
    verifierPrompt: string;
    verifierFeedback: string;
}

export function createCheckMate(executor: TypeChatLanguageModel, verifier: TypeChatLanguageModel, refinementRounds = 3): Checkmate {
    const checkmate = {
        executor,
        verifier,
        refinementRounds,
        maxAttempts: refinementRounds + 2,
        debug: false,
        createExecuteInitialPrompt,
        createExecuteFollowupPrompt,
        createVerifyInitialPrompt,
        createVerifyFollowupPrompt,
        perform,
    };
    return checkmate;

    function logForDebug(message?: any, ...optionalParams: any[]): void {
        if (checkmate.debug) {
            console.log(message, ...optionalParams);
        }
    }

    function warnForDebug(message?: any, ...optionalParams: any[]): void {
        if (checkmate.debug) {
            console.warn(message, ...optionalParams);
        }
    }

    function createChatHistory(chatHistory: RoundRecord[], particialRoundRecord?: Partial<RoundRecord>): string {
        const fullHistory = [...chatHistory];
        if (particialRoundRecord) {
            fullHistory.push(particialRoundRecord as RoundRecord);
        }
        if (fullHistory.length === 0) {
            return '';
        }
        return `---- JSON format Chat History ----\n${JSON.stringify(fullHistory, null, 2)}\n---- End of Chat History ----\n`;
    }

    function createExecuteInitialPrompt(taskDescription: string): string {
        return `As the task executor, your job is to complete the following task to the best of your ability:\n\`\`\`\n${taskDescription}\n\`\`\`\nPlease generate a solution.`;
    }

    function createExecuteFollowupPrompt(): string {
        return `Based on the verifier's feedback. Please refine your solution. Provide your updated solution.`;
    }

    function createVerifyInitialPrompt(taskDescription: string): string {
        return `As the task verifier, your primary job is to critically review the solution generated by the executor based on the following task:\n\`\`\`\n${taskDescription}\n\`\`\`\nPlease prioritize pointing out areas for improvement in the solution.`;
    }

    function createVerifyFollowupPrompt(): string {
        return `The executor has refined their solution based on your previous feedback. As the task verifier, your primary job is again to identify and point out areas that need further refinement.`;
    }

    async function perform(taskDescription: string): Promise<string> {
        const recordHistory: RoundRecord[] = [];
        let attempt = 0;
        while (recordHistory.length < checkmate.refinementRounds && attempt < checkmate.maxAttempts) {
            const round = recordHistory.length + 1;
            try {
                const executorPrompt = recordHistory.length === 0 ?
                    createExecuteInitialPrompt(taskDescription) :
                    createExecuteFollowupPrompt();
                const executorPromptWithChatHistory = createChatHistory(recordHistory) + executorPrompt;
                logForDebug(`>>>> Round ${round} executor prompt with history:\n${executorPromptWithChatHistory}\n`);
                const executorSolution = await executor.complete(executorPromptWithChatHistory);
                logForDebug(`<<<< Round ${round} executor solution:\n${executorSolution}\n`);
                if (recordHistory.length === checkmate.refinementRounds - 1) {
                    return executorSolution;
                }
                const verifierPrompt = recordHistory.length === 0 ?
                    createVerifyInitialPrompt(taskDescription) :
                    createVerifyFollowupPrompt();
                const verifierPromptWithChatHistory = createChatHistory(recordHistory, { executorPrompt, executorSolution }) + verifierPrompt;
                logForDebug(`>>>> Round ${round} verifier prompt with history:\n${verifierPromptWithChatHistory}\n`);
                const verifierFeedback = await verifier.complete(verifierPromptWithChatHistory);
                logForDebug(`<<<< Round ${round} verifier feedback:\n${verifierFeedback}\n`);
                recordHistory.push({
                    executorPrompt,
                    executorSolution,
                    verifierPrompt,
                    verifierFeedback,
                });
            } catch (error) {
                warnForDebug(`⚠︎⚠︎⚠︎⚠︎ Round ${round} error: `, error);
            } finally {
                attempt++;
            }
        }
        if (recordHistory.length === 0) {
            throw new Error(`Failed to generate a solution in ${attempt} attempts.`);
        }
        return recordHistory[recordHistory.length - 1].executorSolution;
    }
}