import { TypeChatLanguageModel } from "./model";

export interface Checkmate {
    executor: TypeChatLanguageModel;
    verifier: TypeChatLanguageModel;
    maxRefinementRounds: number;

    createExecuteInitialPrompt(taskDescription: string): string;
    createExecuteFollowupPrompt(verifierFeedback: string): string;
    createVerifyInitialPrompt(taskDescription: string, executorSolution: string): string;
    createVerifyFollowupPrompt(updatedExecutorSolution: string): string;
    perform(taskDescription: string): Promise<string>;
}

export function createCheckMate(executor: TypeChatLanguageModel, verifier: TypeChatLanguageModel): Checkmate {
    const checkmate = {
        executor,
        verifier,
        maxRefinementRounds: 10,
        createExecuteInitialPrompt,
        createExecuteFollowupPrompt,
        createVerifyInitialPrompt,
        createVerifyFollowupPrompt,
        perform,
    };
    return checkmate;

    function createExecuteInitialPrompt(taskDescription: string): string {
        return `As the task executor, your job is to complete the following task to the best of your ability: ${taskDescription}. Please generate a solution.`;
    }

    function createExecuteFollowupPrompt(verifierFeedback: string): string {
        return `Based on the verifier's feedback: ${verifierFeedback}, please refine your solution. Provide your updated solution.`;
    }

    function createVerifyInitialPrompt(taskDescription: string, executorSolution: string): string {
        return `As the task verifier, your job is to review the solution generated by the executor based on the following task: ${taskDescription}. The executor's solution is: ${executorSolution}. If the solution meets the standard, please respond with: \`{'isSatisfactory': true}\`. If it does not meet the standard, please respond with: \`{'isSatisfactory': false, 'feedback': '<your feedback here>'}\`.`;
    }

    function createVerifyFollowupPrompt(updatedExecutorSolution: string): string {
        return `The executor has refined their solution based on your previous feedback. The updated task solution is: ${updatedExecutorSolution}. As the task verifier, please review it again. If the solution meets the standard, please respond with: \`{'isSatisfactory': true}\`. If it still does not meet the standard, please respond with: \`{'isSatisfactory': false, 'feedback': '<your new feedback here>'}\`.`;
    }

    async function perform(taskDescription: string): Promise<string> {
        let executorPrompt = '';
        let verifierPrompt = '';
        let verifierFeedback;
        for (let i = 0; i < checkmate.maxRefinementRounds; i++) {
            if (i === 0) {
                executorPrompt += createExecuteInitialPrompt(taskDescription) + '\n';
            } else {
                executorPrompt += createExecuteFollowupPrompt(verifierFeedback) + '\n';
            }
            const executorSolution = await executor.complete(executorPrompt);
            if (i === 0) {
                verifierPrompt += createVerifyInitialPrompt(taskDescription, executorSolution) + '\n';
            } else {
                verifierPrompt += createVerifyFollowupPrompt(executorSolution) + '\n';
            }
            const verifierResponseText = await verifier.complete(verifierPrompt);
            const startIndex = verifierResponseText.indexOf("{");
            const endIndex = verifierResponseText.lastIndexOf("}");
            if (!(startIndex >= 0 && endIndex > startIndex)) {
                throw new Error(`Response is not JSON:\n${verifierResponseText}`);
            }
            const jsonText = verifierResponseText.slice(startIndex, endIndex + 1);
            let verifierResponse;
            try {
                verifierResponse = JSON.parse(jsonText);
            } catch (e) {
                throw new Error(`Response is not JSON:\n${verifierResponseText}`);
            }
            if (verifierResponse.isSatisfactory) {
                return executorSolution;
            }
            verifierFeedback = verifierResponse.feedback;
        }
        throw new Error(`Maximum number of refinement rounds exceeded.`);
    }
}