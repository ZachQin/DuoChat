import { TypeChatLanguageModel } from "./model";

export interface Checkmate {
    executor: TypeChatLanguageModel;
    verifier: TypeChatLanguageModel;
    minRefinementRounds: number;
    maxRefinementRounds: number;
    debug: boolean;

    createExecuteInitialPrompt(taskDescription: string): string;
    createExecuteFollowupPrompt(verifierFeedback: string): string;
    createVerifyInitialPrompt(taskDescription: string, executorSolution: string): string;
    createVerifyFollowupPrompt(updatedExecutorSolution: string): string;
    createVerifyInitialPromptBeforeMinRefinementRounds(taskDescription: string, executorSolution: string): string;
    createVerifyFollowupPromptBeforeMinRefinementRounds(updatedExecutorSolution: string): string
    perform(taskDescription: string): Promise<string>;
}

interface RoundRecord {
    executorPrompt: string;
    executorSolution: string;
    verifierPrompt: string;
    verifierFeedback: string;
}

export function createCheckMate(executor: TypeChatLanguageModel, verifier: TypeChatLanguageModel): Checkmate {
    const checkmate = {
        executor,
        verifier,
        minRefinementRounds: 3,
        maxRefinementRounds: 10,
        debug: false,
        createExecuteInitialPrompt,
        createExecuteFollowupPrompt,
        createVerifyInitialPrompt,
        createVerifyFollowupPrompt,
        createVerifyInitialPromptBeforeMinRefinementRounds,
        createVerifyFollowupPromptBeforeMinRefinementRounds,
        perform,
    };
    return checkmate;

    function logForDebug(message?: any, ...optionalParams: any[]): void {
        if (checkmate.debug) {
            console.log(message, ...optionalParams);
        }
    }

    function warnForDebug(message?: any, ...optionalParams: any[]): void {
        if (checkmate.debug) {
            console.warn(message, ...optionalParams);
        }
    }

    function createChatHistory(chatHistory: RoundRecord[], particialRoundRecord?: Partial<RoundRecord>): string {
        if (chatHistory.length === 0 && !particialRoundRecord) {
            return '';
        }
        return `--- JSON format Chat History---\n${JSON.stringify([...chatHistory, particialRoundRecord], null, 2)}\n--- End of Chat History ---\n`;
    }

    function createExecuteInitialPrompt(taskDescription: string): string {
        return `As the task executor, your job is to complete the following task to the best of your ability:\n\`\`\`\n${taskDescription}\n\`\`\`\nPlease generate a solution.`;
    }

    function createExecuteFollowupPrompt(verifierFeedback: string): string {
        return `Based on the verifier's feedback:\n\`\`\`\n${verifierFeedback}\n\`\`\`\nPlease refine your solution. Provide your updated solution.`;
    }

    function createVerifyInitialPrompt(taskDescription: string, executorSolution: string): string {
        return `As the task verifier, your job is to critically review the solution generated by the executor based on the following task:\n\`\`\`\n${taskDescription}\n\`\`\`\nThe executor's solution is:\n\`\`\`\n${executorSolution}\n\`\`\`\nPlease point out both strengths and areas for improvement in the solution. If the solution meets the standard, please respond with: \`{"isSatisfactory": true}\`. If it does not meet the standard, please respond with: \`{"isSatisfactory": false, "feedback": "<your feedback here>"}\`.`;
    }

    function createVerifyFollowupPrompt(updatedExecutorSolution: string): string {
        return `The executor has refined their solution based on your previous feedback. The updated task solution is:\n\`\`\`\n${updatedExecutorSolution}\n\`\`\`\nAs the task verifier, your job is to critically review it again. Please point out both the improvements made and the areas that still need to be addressed. If the solution now meets the standard, please respond with: \`{"isSatisfactory": true}\`. If it still does not meet the standard, please respond with: \`{"isSatisfactory": false, "feedback": "<your new feedback here>"}\`.`;
    }

    function createVerifyInitialPromptBeforeMinRefinementRounds(taskDescription: string, executorSolution: string): string {
        return `As the task verifier, your job is to critically review the solution generated by the executor based on the following task:\n\`\`\`\n${taskDescription}\n\`\`\`\nThe executor's solution is:\n\`\`\`\n${executorSolution}\n\`\`\`\nPlease point out both strengths and areas for improvement in the solution.`;
    }

    function createVerifyFollowupPromptBeforeMinRefinementRounds(updatedExecutorSolution: string): string {
        return `The executor has refined their solution based on your previous feedback. The updated task solution is:\n\`\`\`\n${updatedExecutorSolution}\n\`\`\`\nAs the task verifier, your job is to critically review it again. Please point out both the improvements made and the areas that still need to be addressed.`;
    }

    async function perform(taskDescription: string): Promise<string> {
        const recordHistory: RoundRecord[] = [];
        while (recordHistory.length < checkmate.maxRefinementRounds) {
            const round = recordHistory.length;
            let executorPrompt, executorSolution, verifierPrompt, verifierFeedback;
            try {
                if (recordHistory.length === 0) {
                    executorPrompt = createExecuteInitialPrompt(taskDescription);
                } else {
                    executorPrompt = createExecuteFollowupPrompt(recordHistory[recordHistory.length - 1].verifierFeedback);
                }
                logForDebug(`Round ${round} executor prompt:\n${executorPrompt}\n`);
                const executorPromptWithChatHistory = createChatHistory(recordHistory) + executorPrompt;
                executorSolution = await executor.complete(executorPromptWithChatHistory);
                logForDebug(`Round ${round} executor solution:\n${executorSolution}\n`);
                if (recordHistory.length === 0) {
                    if (round < checkmate.minRefinementRounds) {
                        verifierPrompt = createVerifyInitialPromptBeforeMinRefinementRounds(taskDescription, executorSolution);
                    } else {
                        verifierPrompt = createVerifyInitialPrompt(taskDescription, executorSolution);
                    }
                } else {
                    if (round < checkmate.minRefinementRounds) {
                        verifierPrompt = createVerifyFollowupPromptBeforeMinRefinementRounds(executorSolution);
                    } else {
                        verifierPrompt = createVerifyFollowupPrompt(executorSolution);
                    }
                }
                logForDebug(`Round ${round} verifier prompt:\n${verifierPrompt}\n`);
                const verifierPromptWithChatHistory = createChatHistory(recordHistory, { executorPrompt, executorSolution }) + verifierPrompt;
                const verifierResponseText = await verifier.complete(verifierPromptWithChatHistory);
                logForDebug(`Round ${round} verifier response:\n${verifierResponseText}\n`);
                if (round < checkmate.minRefinementRounds) {
                    verifierFeedback = verifierResponseText;
                } else {
                    const startIndex = verifierResponseText.indexOf("{");
                    const endIndex = verifierResponseText.lastIndexOf("}");
                    if (!(startIndex >= 0 && endIndex > startIndex)) {
                        throw new Error(`Response is not JSON:\n${verifierResponseText}`);
                    }
                    const jsonText = verifierResponseText.slice(startIndex, endIndex + 1);
                    let verifierResponse = JSON.parse(jsonText);
                    if (verifierResponse.isSatisfactory) {
                        return executorSolution;
                    }
                    verifierFeedback = verifierResponse.feedback;
                }
                recordHistory.push({
                    executorPrompt,
                    executorSolution,
                    verifierPrompt,
                    verifierFeedback,
                });
            } catch (error) {
                warnForDebug(`Round ${round} error: `, error);
            }
        }
        warnForDebug(`Max refinement rounds reached.`);
        return recordHistory[recordHistory.length - 1].executorSolution;
    }
}